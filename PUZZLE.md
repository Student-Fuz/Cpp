### Q1：深拷贝与浅/拷贝

直接拷贝称为浅拷贝，深拷贝在计算机中（堆区）开辟一块新的内存地址用于存放复制的对象在堆区存放的内容，


### Q2: new/delete与malloc/free的区别

1. new/delete是C++操作符，malloc/free是库函数
2. ***new分配内存按照数据类型进行分配，malloc分配内存按照大小分配***
3. new在动态分配内存的时候可以初始化对象，调用其构造函数，delete在释放内存时 调用对象的析构函数。
   而malloc只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回NULL。
4. new/delete可以重载，而malloc不行
5. ***new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化***
6. 对于数据C++定义new[]专门进行动态数组分配，用delete[]进行销毁。new[]会一次分配内存，然后多次调用构造函数；delete[]会先多次调用析构函数，然后一次性释放
   new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try…catch语法，而malloc则应该判断指针的返回值。为了兼容很多c程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL；
   malloc能够直观地重新分配内存使用realloc函数进行内存重新分配实现内存的扩充
   new没有这样直观的配套设施来扩充内存。


### Q3: sizeof与strlen(或length())的区别

前者sizeof返回值的单位是比特数，后者strlen/length()返回值是字节数。

strlen是库cstring中的函数，length()是STL容器string的类方法。


### Q4: struct和class区别

在C++中struct和class唯一的区别在于默认的访问权限不同

区别：
- struct默认权限为公共
- **class默认权限为私有**


### Q5: 指针与引用的区别

引用是通过常量指针实现的。

指针可以更换所指对象，而引用无法更换所引向对象。


### Q6: 继承时，父类的析构函数是否为虚函数？构造函数能不能为虚函数？为什么？

继承时，父类的析构函数需要为虚函数，构造函数不能为虚函数。

析构函数需要为虚函数：
1. 因为析构时，需要触发动态多态，期间不仅需要调用父类的析构函数，还需要调用子类的析构函数，以避免子类的内存泄露。
2. 如果父类的析构函数是虚函数，则子类的析构函数一定是虚函数（即使是子类的析构函数不加virtual,这是C++的语法规则）

构造函数不能为虚函数：
从vptr角度解释
虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针(vptr可以参考C++的虚函数表指针vptr)指向，该指针存放在对象的内部空间中，需要调用构造函数完成初始化。如果构造函数是虚函数，那么调用构造函数就需要去找vptr，但此时vptr还没有初始化！

从多态角度解释
虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。
在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数


### Q7: 虚函数实现动态多态的原理

当一个类中出现虚函数或着子类继承了虚函数时，就会在该类中产生一个虚函数表（virtual table），虚函数表实际上是一个函数指针数组（在有的编译器作用下是链表），里面的每一个元素对应指向该类中的某一个虚函数的指针。被该类声明的对象会包含一个虚函数表指针（virtual table pointer），指向该类的虚函数表的地址。


### Q8: 虚函数与纯虚函数的区别

定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。








